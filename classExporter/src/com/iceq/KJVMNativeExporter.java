package com.iceq;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.List;
import java.util.Vector;

import net.sf.rej.java.AccessFlags;
import net.sf.rej.java.ClassFile;
import net.sf.rej.java.JavaType;
import net.sf.rej.java.Method;

public class KJVMNativeExporter
{
	static String	nativeDispatcher;
	static String	nativeMethodDefinitions;
	
	static String[] BOOT_STRAP_CLASS_NAMES = new String[]{
		"java_lang_Object",
		"java_lang_Float",
		"java_lang_String",
		"java_lang_Thread",
		"java_lang_Runtime",
	};
	
	private static boolean isBoostrapClass(String className){
		for(int i = 0; i < BOOT_STRAP_CLASS_NAMES.length;i++)
			if(BOOT_STRAP_CLASS_NAMES[i].equals(className))
				return true;
		return false;
	}

	private static void writeMicrokernelDispatchHeader()
	{
		nativeDispatcher = "// DO NOT CHANGE!!! - AUTOGENERATED\n";
		nativeDispatcher += "// This file is needed for native method dispaching\n";
		nativeDispatcher += "//\n// Copyright (c) 2015 Florin Serban. All rights reserved.\n\n";
		nativeDispatcher += "#ifndef KVM_MICROKERNEL_NATIVE_DISPATCH\n";
		nativeDispatcher += "#define KVM_MICROKERNEL_NATIVE_DISPATCH\n\n";
		nativeDispatcher += "#include \"micro_kernel.h\" \n\n";

		nativeDispatcher += "kvm_internal void kvmParamRead(kvm_mem_pointer out,const NativeType type,const int paramIndex);\n";
		nativeDispatcher += "kvm_internal void kvmParamWrite(kvm_mem_pointer out,const NativeType type,const int paramIndex);\n";
		nativeDispatcher += "kvm_internal void kvmWriteReturn(kvm_mem_pointer in,const NativeType type);\n";
		nativeDispatcher += "\n\nvoid microkernelNativeDispatch(const u2 classId,const u2 methodId){\n";
	}

	private static void writeMicrokernelHeader()
	{
		nativeMethodDefinitions = "#ifndef MICROKERNEL_HEARDER \n";
		nativeMethodDefinitions += "#define MICROKERNEL_HEARDER \n\n";
		nativeMethodDefinitions += "#include \"kvm_type_definitions.h\" \n\n";
	}

	private static void writeMethod( final String className, final Method method, final int methodId)
	{
		JavaType returnType = method.getDescriptor().getReturn();

		
		nativeMethodDefinitions += "\n";
		if(isBoostrapClass(className))
			nativeMethodDefinitions += "kvm_internal";
		nativeMethodDefinitions +=" " + getNativeType(returnType,className) + " " + className + "_" + method.getName() + methodId + "(";

		nativeDispatcher += "\n\t\tif( methodId == " + methodId + "){";

		String methodCall = "\n\t\t\t";
		final String nativeReturnType = getNativeType(returnType,className);
		if (!nativeReturnType.equals("jvoid"))
		{
			methodCall += nativeReturnType + " ret = ";
		}
		methodCall += className + "_" + method.getName() + methodId + "(";

		String paramUpdates = "";
		List<JavaType> params = method.getDescriptor().getParamList();
		for (int k = 0; k < params.size(); k++)
		{
			JavaType param = params.get(k);
			if(param.isPrimitive())
			{
				String paramDef = getNativeType(param,className) + " param" + k;
	
				nativeMethodDefinitions += paramDef;
				nativeDispatcher += "\n\t\t\t" + paramDef + ";\tkvmParamRead(&param" + k + ", " + getNativeTypeName(param) + "," + k + ");";
	
				if (param.getDimensionCount() > 0)
					paramUpdates += "\n\t\t\tkvmParamWrite(&param" + k + ", " + getNativeTypeName(param) + "," + k + ");";
	
				methodCall += " param" + k;
				if (k < params.size() - 1)
				{
					nativeMethodDefinitions += ",";
					methodCall += ",";
				}
			}
		}
		nativeMethodDefinitions += ");\n";

		nativeDispatcher += methodCall + ");";

		if (paramUpdates.length() > 1)
			nativeDispatcher += paramUpdates;

		if (!nativeReturnType.equals("jvoid"))
			nativeDispatcher += "\n\t\t\tkvmWriteReturn(&ret," + getNativeTypeName(returnType) + ");";
		nativeDispatcher += "\n\t\t}";
	}

	private static void writeClass( final KJVMPackageInfo cPK, final KClassFileInfo kclass)
	{
		String className = kclass.getFullClassName().replace(".", "_");
		ClassFile classFile = kclass.getClassFile();

		//native
		//nativeDispatcherImport +="\n#include \""+className +".h\"";
		final List<Method> methods = classFile.getMethods();

		boolean classCheckAdded = false;
		for (int j = 0; j < methods.size(); j++)
		{
			final Method method = methods.get(j);
			if (AccessFlags.isNative(method.getAccessFlags()))
			{
				if (!classCheckAdded)
				{
					classCheckAdded = true;
					nativeDispatcher += "\n\tif(classId == " + cPK.getClassId(kclass.getFullClassName()) + "){";
				}
				writeMethod(className, method, j);
			}
		}
		if (classCheckAdded)
		{
			nativeDispatcher += "\n\t}";
		}
	}

	public static void exportMicroKernel( File folder, KJVMPackageInfo cPK, Vector<KClassFileInfo> microKernelClasses)
	{
		try
		{
			//native
			writeMicrokernelDispatchHeader();

			writeMicrokernelHeader();

			for (int i = 0; i < microKernelClasses.size(); i++)
			{
				KClassFileInfo kclass = microKernelClasses.get(i);
				if (kclass.isExport())
				{
					writeClass(cPK, kclass);
				}
			}
			//native
			nativeDispatcher += "\n}\n#endif\n";
			nativeMethodDefinitions += "#endif\n";

			String kvmNativeDispatchFile = folder.getAbsolutePath() + "/kvm_native_dispatch.c";
			System.out.println("Write kvmNativeDispatchFile:" + kvmNativeDispatchFile);
			BufferedWriter fos = new BufferedWriter(new FileWriter(new File(kvmNativeDispatchFile)));
			fos.write(nativeDispatcher);
			fos.flush();
			fos.close();

			String microkernelHeaderFile = folder.getAbsolutePath() + "/micro_kernel.h";
			System.out.println("Write microkernelHeaderFile:" + microkernelHeaderFile);
			fos = new BufferedWriter(new FileWriter(new File(microkernelHeaderFile)));
			fos.write(nativeMethodDefinitions);
			fos.flush();
			fos.close();

			String microkernelFile = folder.getAbsolutePath() + "/micro_kernel.c";

			File f = new File(microkernelFile);
			if (!f.exists())
			{
				System.out.println("Write microkernelFile:" + microkernelFile);
				fos = new BufferedWriter(new FileWriter(new File(microkernelFile)));
				nativeMethodDefinitions = nativeMethodDefinitions.replace("kvm_type_definitions.h",
						"kvm_type_definitions.h\"\n#include \"micro_kernel.h");
				nativeMethodDefinitions = nativeMethodDefinitions.replace(";", "{}");
				fos.write(nativeMethodDefinitions);
				fos.flush();
				fos.close();
			}
		} catch (Exception ex)
		{
			ex.printStackTrace();
		}
	}

	private static String getNativeType( JavaType type,String crtClassName)
	{
		String ret = "j" + type.getType();
		if (!type.isPrimitive() || type.getDimensionCount() > 1)
		{
			if(isBoostrapClass(crtClassName)){
				return "jvoid";
			}
			//throw exception
		}
		if (type.getDimensionCount() > 0)
			ret += "Array";
		return ret;
	}

	private static String getNativeTypeName( JavaType type)
	{
		String ret = type.getType();
		if (!type.isPrimitive() || type.getDimensionCount() > 1)
		{
			//throw exception
		}
		if (type.getDimensionCount() > 0)
			ret += "Array";
		ret = ret.toUpperCase();
		return ret;
	}
}
